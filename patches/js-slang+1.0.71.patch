diff --git a/node_modules/js-slang/dist/parser/go-slang/go-parser.js b/node_modules/js-slang/dist/parser/go-slang/go-parser.js
new file mode 100644
index 0000000..e00fcf0
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/go-parser.js
@@ -0,0 +1,1093 @@
+// @generated by Peggy 4.0.2.
+//
+// https://peggyjs.org/
+
+"use strict";
+
+
+function peg$subclass(child, parent) {
+  function C() { this.constructor = child; }
+  C.prototype = parent.prototype;
+  child.prototype = new C();
+}
+
+function peg$SyntaxError(message, expected, found, location) {
+  var self = Error.call(this, message);
+  // istanbul ignore next Check is a necessary evil to support older environments
+  if (Object.setPrototypeOf) {
+    Object.setPrototypeOf(self, peg$SyntaxError.prototype);
+  }
+  self.expected = expected;
+  self.found = found;
+  self.location = location;
+  self.name = "SyntaxError";
+  return self;
+}
+
+peg$subclass(peg$SyntaxError, Error);
+
+function peg$padEnd(str, targetLength, padString) {
+  padString = padString || " ";
+  if (str.length > targetLength) { return str; }
+  targetLength -= str.length;
+  padString += padString.repeat(targetLength);
+  return str + padString.slice(0, targetLength);
+}
+
+peg$SyntaxError.prototype.format = function(sources) {
+  var str = "Error: " + this.message;
+  if (this.location) {
+    var src = null;
+    var k;
+    for (k = 0; k < sources.length; k++) {
+      if (sources[k].source === this.location.source) {
+        src = sources[k].text.split(/\r\n|\n|\r/g);
+        break;
+      }
+    }
+    var s = this.location.start;
+    var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
+      ? this.location.source.offset(s)
+      : s;
+    var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
+    if (src) {
+      var e = this.location.end;
+      var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
+      var line = src[s.line - 1];
+      var last = s.line === e.line ? e.column : line.length + 1;
+      var hatLen = (last - s.column) || 1;
+      str += "\n --> " + loc + "\n"
+          + filler + " |\n"
+          + offset_s.line + " | " + line + "\n"
+          + filler + " | " + peg$padEnd("", s.column - 1, ' ')
+          + peg$padEnd("", hatLen, "^");
+    } else {
+      str += "\n at " + loc;
+    }
+  }
+  return str;
+};
+
+peg$SyntaxError.buildMessage = function(expected, found) {
+  var DESCRIBE_EXPECTATION_FNS = {
+    literal: function(expectation) {
+      return "\"" + literalEscape(expectation.text) + "\"";
+    },
+
+    class: function(expectation) {
+      var escapedParts = expectation.parts.map(function(part) {
+        return Array.isArray(part)
+          ? classEscape(part[0]) + "-" + classEscape(part[1])
+          : classEscape(part);
+      });
+
+      return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
+    },
+
+    any: function() {
+      return "any character";
+    },
+
+    end: function() {
+      return "end of input";
+    },
+
+    other: function(expectation) {
+      return expectation.description;
+    }
+  };
+
+  function hex(ch) {
+    return ch.charCodeAt(0).toString(16).toUpperCase();
+  }
+
+  function literalEscape(s) {
+    return s
+      .replace(/\\/g, "\\\\")
+      .replace(/"/g,  "\\\"")
+      .replace(/\0/g, "\\0")
+      .replace(/\t/g, "\\t")
+      .replace(/\n/g, "\\n")
+      .replace(/\r/g, "\\r")
+      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
+      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
+  }
+
+  function classEscape(s) {
+    return s
+      .replace(/\\/g, "\\\\")
+      .replace(/\]/g, "\\]")
+      .replace(/\^/g, "\\^")
+      .replace(/-/g,  "\\-")
+      .replace(/\0/g, "\\0")
+      .replace(/\t/g, "\\t")
+      .replace(/\n/g, "\\n")
+      .replace(/\r/g, "\\r")
+      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
+      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
+  }
+
+  function describeExpectation(expectation) {
+    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
+  }
+
+  function describeExpected(expected) {
+    var descriptions = expected.map(describeExpectation);
+    var i, j;
+
+    descriptions.sort();
+
+    if (descriptions.length > 0) {
+      for (i = 1, j = 1; i < descriptions.length; i++) {
+        if (descriptions[i - 1] !== descriptions[i]) {
+          descriptions[j] = descriptions[i];
+          j++;
+        }
+      }
+      descriptions.length = j;
+    }
+
+    switch (descriptions.length) {
+      case 1:
+        return descriptions[0];
+
+      case 2:
+        return descriptions[0] + " or " + descriptions[1];
+
+      default:
+        return descriptions.slice(0, -1).join(", ")
+          + ", or "
+          + descriptions[descriptions.length - 1];
+    }
+  }
+
+  function describeFound(found) {
+    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
+  }
+
+  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
+};
+
+function peg$parse(input, options) {
+  options = options !== undefined ? options : {};
+
+  var peg$FAILED = {};
+  var peg$source = options.grammarSource;
+
+  var peg$startRuleFunctions = { GoFile: peg$parseGoFile };
+  var peg$startRuleFunction = peg$parseGoFile;
+
+  var peg$c0 = "package";
+  var peg$c1 = "import";
+  var peg$c2 = "(";
+  var peg$c3 = ")";
+  var peg$c4 = "\"";
+  var peg$c5 = "func";
+  var peg$c6 = "{";
+  var peg$c7 = "}";
+  var peg$c8 = "=";
+  var peg$c9 = ";";
+
+  var peg$r0 = /^[a-zA-Z_]/;
+  var peg$r1 = /^[a-zA-Z_0-9]/;
+  var peg$r2 = /^[a-zA-Z0-9_\/]/;
+  var peg$r3 = /^[^"]/;
+  var peg$r4 = /^[0-9]/;
+  var peg$r5 = /^[ \t\n\r]/;
+
+  var peg$e0 = peg$literalExpectation("package", false);
+  var peg$e1 = peg$classExpectation([["a", "z"], ["A", "Z"], "_"], false, false);
+  var peg$e2 = peg$classExpectation([["a", "z"], ["A", "Z"], "_", ["0", "9"]], false, false);
+  var peg$e3 = peg$literalExpectation("import", false);
+  var peg$e4 = peg$literalExpectation("(", false);
+  var peg$e5 = peg$literalExpectation(")", false);
+  var peg$e6 = peg$literalExpectation("\"", false);
+  var peg$e7 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "/"], false, false);
+  var peg$e8 = peg$literalExpectation("func", false);
+  var peg$e9 = peg$literalExpectation("{", false);
+  var peg$e10 = peg$literalExpectation("}", false);
+  var peg$e11 = peg$literalExpectation("=", false);
+  var peg$e12 = peg$literalExpectation(";", false);
+  var peg$e13 = peg$classExpectation(["\""], true, false);
+  var peg$e14 = peg$classExpectation([["0", "9"]], false, false);
+  var peg$e15 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);
+  var peg$e16 = peg$anyExpectation();
+
+  var peg$currPos = options.peg$currPos | 0;
+  var peg$savedPos = peg$currPos;
+  var peg$posDetailsCache = [{ line: 1, column: 1 }];
+  var peg$maxFailPos = peg$currPos;
+  var peg$maxFailExpected = options.peg$maxFailExpected || [];
+  var peg$silentFails = options.peg$silentFails | 0;
+
+  var peg$result;
+
+  if (options.startRule) {
+    if (!(options.startRule in peg$startRuleFunctions)) {
+      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
+    }
+
+    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
+  }
+
+  function text() {
+    return input.substring(peg$savedPos, peg$currPos);
+  }
+
+  function offset() {
+    return peg$savedPos;
+  }
+
+  function range() {
+    return {
+      source: peg$source,
+      start: peg$savedPos,
+      end: peg$currPos
+    };
+  }
+
+  function location() {
+    return peg$computeLocation(peg$savedPos, peg$currPos);
+  }
+
+  function expected(description, location) {
+    location = location !== undefined
+      ? location
+      : peg$computeLocation(peg$savedPos, peg$currPos);
+
+    throw peg$buildStructuredError(
+      [peg$otherExpectation(description)],
+      input.substring(peg$savedPos, peg$currPos),
+      location
+    );
+  }
+
+  function error(message, location) {
+    location = location !== undefined
+      ? location
+      : peg$computeLocation(peg$savedPos, peg$currPos);
+
+    throw peg$buildSimpleError(message, location);
+  }
+
+  function peg$literalExpectation(text, ignoreCase) {
+    return { type: "literal", text: text, ignoreCase: ignoreCase };
+  }
+
+  function peg$classExpectation(parts, inverted, ignoreCase) {
+    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
+  }
+
+  function peg$anyExpectation() {
+    return { type: "any" };
+  }
+
+  function peg$endExpectation() {
+    return { type: "end" };
+  }
+
+  function peg$otherExpectation(description) {
+    return { type: "other", description: description };
+  }
+
+  function peg$computePosDetails(pos) {
+    var details = peg$posDetailsCache[pos];
+    var p;
+
+    if (details) {
+      return details;
+    } else {
+      if (pos >= peg$posDetailsCache.length) {
+        p = peg$posDetailsCache.length - 1;
+      } else {
+        p = pos;
+        while (!peg$posDetailsCache[--p]) {}
+      }
+
+      details = peg$posDetailsCache[p];
+      details = {
+        line: details.line,
+        column: details.column
+      };
+
+      while (p < pos) {
+        if (input.charCodeAt(p) === 10) {
+          details.line++;
+          details.column = 1;
+        } else {
+          details.column++;
+        }
+
+        p++;
+      }
+
+      peg$posDetailsCache[pos] = details;
+
+      return details;
+    }
+  }
+
+  function peg$computeLocation(startPos, endPos, offset) {
+    var startPosDetails = peg$computePosDetails(startPos);
+    var endPosDetails = peg$computePosDetails(endPos);
+
+    var res = {
+      source: peg$source,
+      start: {
+        offset: startPos,
+        line: startPosDetails.line,
+        column: startPosDetails.column
+      },
+      end: {
+        offset: endPos,
+        line: endPosDetails.line,
+        column: endPosDetails.column
+      }
+    };
+    if (offset && peg$source && (typeof peg$source.offset === "function")) {
+      res.start = peg$source.offset(res.start);
+      res.end = peg$source.offset(res.end);
+    }
+    return res;
+  }
+
+  function peg$fail(expected) {
+    if (peg$currPos < peg$maxFailPos) { return; }
+
+    if (peg$currPos > peg$maxFailPos) {
+      peg$maxFailPos = peg$currPos;
+      peg$maxFailExpected = [];
+    }
+
+    peg$maxFailExpected.push(expected);
+  }
+
+  function peg$buildSimpleError(message, location) {
+    return new peg$SyntaxError(message, null, null, location);
+  }
+
+  function peg$buildStructuredError(expected, found, location) {
+    return new peg$SyntaxError(
+      peg$SyntaxError.buildMessage(expected, found),
+      expected,
+      found,
+      location
+    );
+  }
+
+  function peg$parseGoFile() {
+    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
+
+    s0 = peg$currPos;
+    if (input.substr(peg$currPos, 7) === peg$c0) {
+      s1 = peg$c0;
+      peg$currPos += 7;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e0); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = peg$parsews();
+      s3 = peg$parsePackageName();
+      if (s3 !== peg$FAILED) {
+        s4 = peg$parsews();
+        s5 = peg$parseImports();
+        if (s5 !== peg$FAILED) {
+          s6 = peg$parsews();
+          s7 = peg$parseFunctions();
+          s8 = peg$parseEOF();
+          if (s8 !== peg$FAILED) {
+            s1 = [s1, s2, s3, s4, s5, s6, s7, s8];
+            s0 = s1;
+          } else {
+            peg$currPos = s0;
+            s0 = peg$FAILED;
+          }
+        } else {
+          peg$currPos = s0;
+          s0 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s0;
+        s0 = peg$FAILED;
+      }
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parsePackageName() {
+    var s0, s1, s2, s3;
+
+    s0 = peg$currPos;
+    s1 = input.charAt(peg$currPos);
+    if (peg$r0.test(s1)) {
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e1); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = input.charAt(peg$currPos);
+      if (peg$r1.test(s3)) {
+        peg$currPos++;
+      } else {
+        s3 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e2); }
+      }
+      while (s3 !== peg$FAILED) {
+        s2.push(s3);
+        s3 = input.charAt(peg$currPos);
+        if (peg$r1.test(s3)) {
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e2); }
+        }
+      }
+      s1 = [s1, s2];
+      s0 = s1;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseImports() {
+    var s0, s1, s2, s3, s4, s5, s6;
+
+    s0 = peg$currPos;
+    s1 = peg$currPos;
+    if (input.substr(peg$currPos, 6) === peg$c1) {
+      s2 = peg$c1;
+      peg$currPos += 6;
+    } else {
+      s2 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e3); }
+    }
+    if (s2 !== peg$FAILED) {
+      s3 = peg$parsews();
+      if (input.charCodeAt(peg$currPos) === 40) {
+        s4 = peg$c2;
+        peg$currPos++;
+      } else {
+        s4 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e4); }
+      }
+      if (s4 !== peg$FAILED) {
+        s5 = peg$parseImportList();
+        if (s5 !== peg$FAILED) {
+          if (input.charCodeAt(peg$currPos) === 41) {
+            s6 = peg$c3;
+            peg$currPos++;
+          } else {
+            s6 = peg$FAILED;
+            if (peg$silentFails === 0) { peg$fail(peg$e5); }
+          }
+          if (s6 !== peg$FAILED) {
+            s2 = [s2, s3, s4, s5, s6];
+            s1 = s2;
+          } else {
+            peg$currPos = s1;
+            s1 = peg$FAILED;
+          }
+        } else {
+          peg$currPos = s1;
+          s1 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s1;
+        s1 = peg$FAILED;
+      }
+    } else {
+      peg$currPos = s1;
+      s1 = peg$FAILED;
+    }
+    if (s1 === peg$FAILED) {
+      s1 = peg$currPos;
+      if (input.substr(peg$currPos, 6) === peg$c1) {
+        s2 = peg$c1;
+        peg$currPos += 6;
+      } else {
+        s2 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e3); }
+      }
+      if (s2 !== peg$FAILED) {
+        s3 = peg$parsews();
+        s4 = peg$parseImport();
+        if (s4 !== peg$FAILED) {
+          s2 = [s2, s3, s4];
+          s1 = s2;
+        } else {
+          peg$currPos = s1;
+          s1 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s1;
+        s1 = peg$FAILED;
+      }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = peg$parsews();
+      s1 = [s1, s2];
+      s0 = s1;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseImport() {
+    var s0, s1, s2, s3;
+
+    s0 = peg$currPos;
+    if (input.charCodeAt(peg$currPos) === 34) {
+      s1 = peg$c4;
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e6); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = input.charAt(peg$currPos);
+      if (peg$r2.test(s3)) {
+        peg$currPos++;
+      } else {
+        s3 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e7); }
+      }
+      if (s3 !== peg$FAILED) {
+        while (s3 !== peg$FAILED) {
+          s2.push(s3);
+          s3 = input.charAt(peg$currPos);
+          if (peg$r2.test(s3)) {
+            peg$currPos++;
+          } else {
+            s3 = peg$FAILED;
+            if (peg$silentFails === 0) { peg$fail(peg$e7); }
+          }
+        }
+      } else {
+        s2 = peg$FAILED;
+      }
+      if (s2 !== peg$FAILED) {
+        if (input.charCodeAt(peg$currPos) === 34) {
+          s3 = peg$c4;
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e6); }
+        }
+        if (s3 !== peg$FAILED) {
+          s1 = [s1, s2, s3];
+          s0 = s1;
+        } else {
+          peg$currPos = s0;
+          s0 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s0;
+        s0 = peg$FAILED;
+      }
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseImportList() {
+    var s0, s1, s2, s3, s4, s5;
+
+    s0 = peg$currPos;
+    s1 = peg$parseImport();
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = peg$currPos;
+      s4 = peg$parsews();
+      s5 = peg$parseImport();
+      if (s5 !== peg$FAILED) {
+        s4 = [s4, s5];
+        s3 = s4;
+      } else {
+        peg$currPos = s3;
+        s3 = peg$FAILED;
+      }
+      while (s3 !== peg$FAILED) {
+        s2.push(s3);
+        s3 = peg$currPos;
+        s4 = peg$parsews();
+        s5 = peg$parseImport();
+        if (s5 !== peg$FAILED) {
+          s4 = [s4, s5];
+          s3 = s4;
+        } else {
+          peg$currPos = s3;
+          s3 = peg$FAILED;
+        }
+      }
+      s1 = [s1, s2];
+      s0 = s1;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseFunctions() {
+    var s0, s1, s2, s3;
+
+    s0 = [];
+    s1 = peg$currPos;
+    s2 = peg$parseFunction();
+    if (s2 !== peg$FAILED) {
+      s3 = peg$parsews();
+      s2 = [s2, s3];
+      s1 = s2;
+    } else {
+      peg$currPos = s1;
+      s1 = peg$FAILED;
+    }
+    while (s1 !== peg$FAILED) {
+      s0.push(s1);
+      s1 = peg$currPos;
+      s2 = peg$parseFunction();
+      if (s2 !== peg$FAILED) {
+        s3 = peg$parsews();
+        s2 = [s2, s3];
+        s1 = s2;
+      } else {
+        peg$currPos = s1;
+        s1 = peg$FAILED;
+      }
+    }
+
+    return s0;
+  }
+
+  function peg$parseFunction() {
+    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
+
+    s0 = peg$currPos;
+    if (input.substr(peg$currPos, 4) === peg$c5) {
+      s1 = peg$c5;
+      peg$currPos += 4;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e8); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = peg$parsews();
+      s3 = peg$parseFunctionName();
+      if (s3 !== peg$FAILED) {
+        s4 = peg$parsews();
+        if (input.charCodeAt(peg$currPos) === 40) {
+          s5 = peg$c2;
+          peg$currPos++;
+        } else {
+          s5 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e4); }
+        }
+        if (s5 !== peg$FAILED) {
+          if (input.charCodeAt(peg$currPos) === 41) {
+            s6 = peg$c3;
+            peg$currPos++;
+          } else {
+            s6 = peg$FAILED;
+            if (peg$silentFails === 0) { peg$fail(peg$e5); }
+          }
+          if (s6 !== peg$FAILED) {
+            s7 = peg$parsews();
+            if (input.charCodeAt(peg$currPos) === 123) {
+              s8 = peg$c6;
+              peg$currPos++;
+            } else {
+              s8 = peg$FAILED;
+              if (peg$silentFails === 0) { peg$fail(peg$e9); }
+            }
+            if (s8 !== peg$FAILED) {
+              s9 = peg$parseStatements();
+              if (input.charCodeAt(peg$currPos) === 125) {
+                s10 = peg$c7;
+                peg$currPos++;
+              } else {
+                s10 = peg$FAILED;
+                if (peg$silentFails === 0) { peg$fail(peg$e10); }
+              }
+              if (s10 !== peg$FAILED) {
+                s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10];
+                s0 = s1;
+              } else {
+                peg$currPos = s0;
+                s0 = peg$FAILED;
+              }
+            } else {
+              peg$currPos = s0;
+              s0 = peg$FAILED;
+            }
+          } else {
+            peg$currPos = s0;
+            s0 = peg$FAILED;
+          }
+        } else {
+          peg$currPos = s0;
+          s0 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s0;
+        s0 = peg$FAILED;
+      }
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseFunctionName() {
+    var s0, s1, s2, s3;
+
+    s0 = peg$currPos;
+    s1 = input.charAt(peg$currPos);
+    if (peg$r0.test(s1)) {
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e1); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = input.charAt(peg$currPos);
+      if (peg$r1.test(s3)) {
+        peg$currPos++;
+      } else {
+        s3 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e2); }
+      }
+      while (s3 !== peg$FAILED) {
+        s2.push(s3);
+        s3 = input.charAt(peg$currPos);
+        if (peg$r1.test(s3)) {
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e2); }
+        }
+      }
+      s1 = [s1, s2];
+      s0 = s1;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseStatements() {
+    var s0, s1, s2, s3;
+
+    s0 = [];
+    s1 = peg$currPos;
+    s2 = peg$parseStatement();
+    if (s2 !== peg$FAILED) {
+      s3 = peg$parsews();
+      s2 = [s2, s3];
+      s1 = s2;
+    } else {
+      peg$currPos = s1;
+      s1 = peg$FAILED;
+    }
+    while (s1 !== peg$FAILED) {
+      s0.push(s1);
+      s1 = peg$currPos;
+      s2 = peg$parseStatement();
+      if (s2 !== peg$FAILED) {
+        s3 = peg$parsews();
+        s2 = [s2, s3];
+        s1 = s2;
+      } else {
+        peg$currPos = s1;
+        s1 = peg$FAILED;
+      }
+    }
+
+    return s0;
+  }
+
+  function peg$parseStatement() {
+    var s0, s1, s2, s3, s4, s5, s6, s7;
+
+    s0 = peg$currPos;
+    s1 = input.charAt(peg$currPos);
+    if (peg$r0.test(s1)) {
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e1); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = input.charAt(peg$currPos);
+      if (peg$r1.test(s3)) {
+        peg$currPos++;
+      } else {
+        s3 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e2); }
+      }
+      while (s3 !== peg$FAILED) {
+        s2.push(s3);
+        s3 = input.charAt(peg$currPos);
+        if (peg$r1.test(s3)) {
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e2); }
+        }
+      }
+      s3 = peg$parsews();
+      if (input.charCodeAt(peg$currPos) === 61) {
+        s4 = peg$c8;
+        peg$currPos++;
+      } else {
+        s4 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e11); }
+      }
+      if (s4 !== peg$FAILED) {
+        s5 = peg$parsews();
+        s6 = peg$parseExpression();
+        if (s6 !== peg$FAILED) {
+          if (input.charCodeAt(peg$currPos) === 59) {
+            s7 = peg$c9;
+            peg$currPos++;
+          } else {
+            s7 = peg$FAILED;
+            if (peg$silentFails === 0) { peg$fail(peg$e12); }
+          }
+          if (s7 !== peg$FAILED) {
+            s1 = [s1, s2, s3, s4, s5, s6, s7];
+            s0 = s1;
+          } else {
+            peg$currPos = s0;
+            s0 = peg$FAILED;
+          }
+        } else {
+          peg$currPos = s0;
+          s0 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s0;
+        s0 = peg$FAILED;
+      }
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+
+  function peg$parseExpression() {
+    var s0, s1, s2, s3;
+
+    s0 = peg$currPos;
+    s1 = input.charAt(peg$currPos);
+    if (peg$r0.test(s1)) {
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e1); }
+    }
+    if (s1 !== peg$FAILED) {
+      s2 = [];
+      s3 = input.charAt(peg$currPos);
+      if (peg$r1.test(s3)) {
+        peg$currPos++;
+      } else {
+        s3 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e2); }
+      }
+      while (s3 !== peg$FAILED) {
+        s2.push(s3);
+        s3 = input.charAt(peg$currPos);
+        if (peg$r1.test(s3)) {
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e2); }
+        }
+      }
+      s1 = [s1, s2];
+      s0 = s1;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+    if (s0 === peg$FAILED) {
+      s0 = peg$currPos;
+      if (input.charCodeAt(peg$currPos) === 34) {
+        s1 = peg$c4;
+        peg$currPos++;
+      } else {
+        s1 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e6); }
+      }
+      if (s1 !== peg$FAILED) {
+        s2 = [];
+        s3 = input.charAt(peg$currPos);
+        if (peg$r3.test(s3)) {
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e13); }
+        }
+        while (s3 !== peg$FAILED) {
+          s2.push(s3);
+          s3 = input.charAt(peg$currPos);
+          if (peg$r3.test(s3)) {
+            peg$currPos++;
+          } else {
+            s3 = peg$FAILED;
+            if (peg$silentFails === 0) { peg$fail(peg$e13); }
+          }
+        }
+        if (input.charCodeAt(peg$currPos) === 34) {
+          s3 = peg$c4;
+          peg$currPos++;
+        } else {
+          s3 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e6); }
+        }
+        if (s3 !== peg$FAILED) {
+          s1 = [s1, s2, s3];
+          s0 = s1;
+        } else {
+          peg$currPos = s0;
+          s0 = peg$FAILED;
+        }
+      } else {
+        peg$currPos = s0;
+        s0 = peg$FAILED;
+      }
+      if (s0 === peg$FAILED) {
+        s0 = [];
+        s1 = input.charAt(peg$currPos);
+        if (peg$r4.test(s1)) {
+          peg$currPos++;
+        } else {
+          s1 = peg$FAILED;
+          if (peg$silentFails === 0) { peg$fail(peg$e14); }
+        }
+        if (s1 !== peg$FAILED) {
+          while (s1 !== peg$FAILED) {
+            s0.push(s1);
+            s1 = input.charAt(peg$currPos);
+            if (peg$r4.test(s1)) {
+              peg$currPos++;
+            } else {
+              s1 = peg$FAILED;
+              if (peg$silentFails === 0) { peg$fail(peg$e14); }
+            }
+          }
+        } else {
+          s0 = peg$FAILED;
+        }
+      }
+    }
+
+    return s0;
+  }
+
+  function peg$parsews() {
+    var s0, s1;
+
+    s0 = [];
+    s1 = input.charAt(peg$currPos);
+    if (peg$r5.test(s1)) {
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e15); }
+    }
+    while (s1 !== peg$FAILED) {
+      s0.push(s1);
+      s1 = input.charAt(peg$currPos);
+      if (peg$r5.test(s1)) {
+        peg$currPos++;
+      } else {
+        s1 = peg$FAILED;
+        if (peg$silentFails === 0) { peg$fail(peg$e15); }
+      }
+    }
+
+    return s0;
+  }
+
+  function peg$parseEOF() {
+    var s0, s1;
+
+    s0 = peg$currPos;
+    peg$silentFails++;
+    if (input.length > peg$currPos) {
+      s1 = input.charAt(peg$currPos);
+      peg$currPos++;
+    } else {
+      s1 = peg$FAILED;
+      if (peg$silentFails === 0) { peg$fail(peg$e16); }
+    }
+    peg$silentFails--;
+    if (s1 === peg$FAILED) {
+      s0 = undefined;
+    } else {
+      peg$currPos = s0;
+      s0 = peg$FAILED;
+    }
+
+    return s0;
+  }
+  peg$result = peg$startRuleFunction();
+
+  if (options.peg$library) {
+    return /** @type {any} */ ({
+      peg$result,
+      peg$currPos,
+      peg$FAILED,
+      peg$maxFailExpected,
+      peg$maxFailPos
+    });
+  }
+  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
+    return peg$result;
+  } else {
+    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
+      peg$fail(peg$endExpectation());
+    }
+
+    throw peg$buildStructuredError(
+      peg$maxFailExpected,
+      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
+      peg$maxFailPos < input.length
+        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
+        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
+    );
+  }
+}
+
+module.exports = {
+  StartRules: ["GoFile"],
+  SyntaxError: peg$SyntaxError,
+  parse: peg$parse
+};
diff --git a/node_modules/js-slang/dist/parser/go-slang/go.js b/node_modules/js-slang/dist/parser/go-slang/go.js
new file mode 100644
index 0000000..574490a
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/go.js
@@ -0,0 +1,224 @@
+// Generated automatically by nearley, version 2.20.1
+// http://github.com/Hardmath123/nearley
+(function () {
+function id(x) { return x[0]; }
+var grammar = {
+    Lexer: undefined,
+    ParserRules: [
+    {"name": "input", "symbols": ["_", "expr", "_"], "postprocess": (data) => data[1]},
+    {"name": "value", "symbols": ["number"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[0]
+            };
+        }
+                        },
+    {"name": "value", "symbols": ["boolean"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[0]
+            };
+        }
+                        },
+    {"name": "value", "symbols": ["myNull"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[0]
+            };
+        }
+                        },
+    {"name": "value", "symbols": ["string"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[0]
+            };
+        }
+                        },
+    {"name": "value", "symbols": ["array"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[0]
+            };
+        }
+                        },
+    {"name": "array", "symbols": [{"literal":"["}, "_", "array_items", "_", {"literal":"]"}], "postprocess": (data) => data[2]},
+    {"name": "array", "symbols": [{"literal":"["}, "_", {"literal":"]"}], "postprocess": () => []},
+    {"name": "array_items", "symbols": ["value"], "postprocess": (data) => [data[0]]},
+    {"name": "array_items", "symbols": ["value", "_", {"literal":","}, "_", "array_items"], "postprocess": (data) => [data[0], ...data[4]]},
+    {"name": "string", "symbols": [{"literal":"\""}, "characters", {"literal":"\""}], "postprocess": (data) => data[1]},
+    {"name": "characters", "symbols": ["character"], "postprocess": id},
+    {"name": "characters", "symbols": ["character", "characters"], "postprocess": (data) => data[0] + data[1]},
+    {"name": "character", "symbols": [/[^\"\\]/], "postprocess": id},
+    {"name": "character", "symbols": [{"literal":"\\"}, "escape"], "postprocess": (data) => data[1]},
+    {"name": "escape", "symbols": [{"literal":"\""}], "postprocess": () => '"'},
+    {"name": "escape", "symbols": [{"literal":"\\"}], "postprocess": () => "\\"},
+    {"name": "escape", "symbols": [{"literal":"/"}], "postprocess": () => "/"},
+    {"name": "escape", "symbols": [{"literal":"b"}], "postprocess": () => "\b"},
+    {"name": "escape", "symbols": [{"literal":"f"}], "postprocess": () => "\f"},
+    {"name": "escape", "symbols": [{"literal":"n"}], "postprocess": () => "\n"},
+    {"name": "escape", "symbols": [{"literal":"r"}], "postprocess": () => "\r"},
+    {"name": "escape", "symbols": [{"literal":"t"}], "postprocess": () => "\t"},
+    {"name": "escape", "symbols": [{"literal":"u"}, "hex", "hex", "hex", "hex"], "postprocess": 
+        (data) => {
+            const code = (((data[1] * 16) + data[2] * 16) + data[3] * 16) + data[4];
+            return String.fromCharCode(code);
+        }
+                },
+    {"name": "hex", "symbols": ["digit"], "postprocess": id},
+    {"name": "hex", "symbols": [/[a-fA-F]/], "postprocess": 
+        (data) => {
+            switch (data[0].toLowerCase()) {
+                case "a":
+                    return 10;
+                case "b":
+                    return 11;
+                case "c":
+                    return 12;
+                case "d":
+                    return 13;
+                case "e":
+                    return 14;
+                case "f":
+                    return 15;
+            }
+        }
+                },
+    {"name": "myNull$string$1", "symbols": [{"literal":"n"}, {"literal":"u"}, {"literal":"l"}, {"literal":"l"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "myNull", "symbols": ["myNull$string$1"], "postprocess": (data) => null},
+    {"name": "number", "symbols": ["digits", {"literal":"."}, "digits"], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: Number(data[0] + "." + data[2])
+            }
+        }
+                                    },
+    {"name": "number", "symbols": ["digits"], "postprocess":  (data) => {
+                return {
+                    tag: "lit",
+                    val: Number(data.join(""))
+                }
+        }
+                 },
+    {"name": "digits", "symbols": ["digit"], "postprocess": id},
+    {"name": "digits", "symbols": ["digit", "digits"], "postprocess": (data) => data.join("")},
+    {"name": "digit", "symbols": [/[0-9]/], "postprocess": id},
+    {"name": "boolean$string$1", "symbols": [{"literal":"t"}, {"literal":"r"}, {"literal":"u"}, {"literal":"e"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "boolean", "symbols": ["boolean$string$1"], "postprocess": () => true},
+    {"name": "boolean$string$2", "symbols": [{"literal":"f"}, {"literal":"a"}, {"literal":"l"}, {"literal":"s"}, {"literal":"e"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "boolean", "symbols": ["boolean$string$2"], "postprocess": () => false},
+    {"name": "_$ebnf$1", "symbols": []},
+    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", /[ \t\n]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
+    {"name": "_", "symbols": ["_$ebnf$1"]},
+    {"name": "additive", "symbols": ["multiplicative", "_", /[+-]/, "_", "additive"], "postprocess": 
+        (data) => {
+            return {
+                tag: "binop",
+                sym: data[2],
+                frst: data[0],
+                scnd: data[4]
+            };
+        }
+                        },
+    {"name": "additive", "symbols": ["multiplicative"], "postprocess": id},
+    {"name": "binop", "symbols": ["additive", "_", /[+-<>=]/, "_", "binop"], "postprocess": 
+        (data) => {
+            return {
+                tag: "binop",
+                sym: data[2],
+                frst: data[0],
+                scnd: data[4]
+            };
+        }
+                    },
+    {"name": "binop", "symbols": ["multiplicative"], "postprocess": id},
+    {"name": "binlog$string$1", "symbols": [{"literal":"&"}, {"literal":"&"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "binlog", "symbols": ["expr", "_", "binlog$string$1", "_", "expr"], "postprocess": 
+        (data) => {
+            return {
+                tag: "binlog",
+                sym: "&&",
+                frst: data[0],
+                scnd: data[4]
+            };
+        }
+                    },
+    {"name": "binlog$string$2", "symbols": [{"literal":"|"}, {"literal":"|"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "binlog", "symbols": ["expr", "_", "binlog$string$2", "_", "expr"], "postprocess": 
+        (data) => {
+            return {
+                tag: "binlog",
+                sym: "||",
+                frst: data[0],
+                scnd: data[4]
+            };
+        }
+                    },
+    {"name": "multiplicative", "symbols": ["unary_expr", "_", /[*/]/, "_", "multiplicative"], "postprocess": 
+        (data) => {
+            return {
+                tag: "binop",
+                sym: data[2],
+                frst: data[0],
+                scnd: data[4]
+            };
+        }
+                        },
+    {"name": "multiplicative", "symbols": ["unary_expr"], "postprocess": id},
+    {"name": "unary_expr", "symbols": ["number"], "postprocess": id},
+    {"name": "unary_expr", "symbols": [{"literal":"("}, "_", "additive", "_", {"literal":")"}], "postprocess": 
+        (data) => {
+            return {
+                tag: "lit",
+                val: data[2]
+            }
+        }
+                        },
+    {"name": "unary_expr", "symbols": ["function"], "postprocess": id},
+    {"name": "unop_expr", "symbols": [{"literal":"!"}, "boolean"], "postprocess": 
+        (data) => {
+            return {
+                tag: "unop",
+                sym: "!",
+                expr: data[1]
+            };
+        }
+                        },
+    {"name": "unop_expr", "symbols": ["unary_expr"], "postprocess": id},
+    {"name": "pgrm", "symbols": ["expr"], "postprocess": id},
+    {"name": "expr", "symbols": ["value"], "postprocess": (data) => data[0]},
+    {"name": "expr", "symbols": ["binop"], "postprocess": (data) => data[0]},
+    {"name": "expr", "symbols": ["binlog"], "postprocess": (data) => data[0]},
+    {"name": "expr", "symbols": ["unop_expr"], "postprocess": (data) => data[0]},
+    {"name": "expr", "symbols": [{"literal":"("}, "expr", {"literal":")"}], "postprocess": (data) => data[1]},
+    {"name": "function", "symbols": ["builtin_fnct", {"literal":"("}, "_", "args", "_", {"literal":")"}], "postprocess": 
+        (data) => {
+            const fn = data[0];
+            const args = data[3];
+            const fs = args[0];
+            const sc = args[1];
+            switch(fn) {
+                case "sqrt":
+                    return fs * fs
+            }
+        }
+                        },
+    {"name": "args", "symbols": ["additive", "_", {"literal":","}, "_", "args"], "postprocess": data => [data[0], ...data[4]]},
+    {"name": "args", "symbols": ["additive"], "postprocess": data => [data[0]]},
+    {"name": "builtin_fnct$string$1", "symbols": [{"literal":"s"}, {"literal":"q"}, {"literal":"r"}, {"literal":"t"}], "postprocess": function joiner(d) {return d.join('');}},
+    {"name": "builtin_fnct", "symbols": ["builtin_fnct$string$1"], "postprocess": id},
+    {"name": "operator", "symbols": [/[+\-*/]/], "postprocess": id}
+]
+  , ParserStart: "input"
+}
+if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
+   module.exports = grammar;
+} else {
+   window.grammar = grammar;
+}
+})();
diff --git a/node_modules/js-slang/dist/parser/go-slang/go.ne b/node_modules/js-slang/dist/parser/go-slang/go.ne
new file mode 100644
index 0000000..137676f
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/go.ne
@@ -0,0 +1,230 @@
+input -> _ expr _ {% (data) => data[1] %}
+
+value -> number {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[0]
+                        };
+                    }
+                %}
+     | boolean {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[0]
+                        };
+                    }
+                %}
+     | myNull {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[0]
+                        };
+                    }
+                %}
+     | string {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[0]
+                        };
+                    }
+                %}
+     | array {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[0]
+                        };
+                    }
+                %}
+
+array -> "[" _ array_items _ "]" {% (data) => data[2] %}
+    | "[" _ "]" {% () => [] %}
+array_items -> value {% (data) => [data[0]] %}
+    | value _ "," _ array_items {% (data) => [data[0], ...data[4]] %}
+
+string -> "\"" characters "\"" {% (data) => data[1] %}
+characters -> character {% id %}
+    | character characters {% (data) => data[0] + data[1] %}
+character -> [^\"\\] {% id %}
+    | "\\" escape {% (data) => data[1] %}
+escape -> "\"" {% () => '"' %}
+    | "\\" {% () => "\\" %}
+    | "/" {% () => "/" %}
+    | "b" {% () => "\b" %}
+    | "f" {% () => "\f" %}
+    | "n" {% () => "\n" %}
+    | "r" {% () => "\r" %}
+    | "t" {% () => "\t" %}
+    | "u" hex hex hex hex
+        {%
+            (data) => {
+                const code = (((data[1] * 16) + data[2] * 16) + data[3] * 16) + data[4];
+                return String.fromCharCode(code);
+            }
+        %}
+hex -> digit {% id %}
+    | [a-fA-F]
+        {%
+            (data) => {
+                switch (data[0].toLowerCase()) {
+                    case "a":
+                        return 10;
+                    case "b":
+                        return 11;
+                    case "c":
+                        return 12;
+                    case "d":
+                        return 13;
+                    case "e":
+                        return 14;
+                    case "f":
+                        return 15;
+                }
+            }
+        %}
+
+myNull -> "null" {% (data) => null %}
+
+number -> digits "." digits {%
+                                (data) => {
+                                    return {
+                                        tag: "lit",
+                                        val: Number(data[0] + "." + data[2])
+                                    }
+                                }
+                            %}
+    | digits {% (data) => {
+                return {
+                    tag: "lit",
+                    val: Number(data.join(""))
+                }
+        }
+                 %}
+digits -> digit {% id %}
+    | digit digits {% (data) => data.join("") %}
+digit -> [0-9] {% id %}
+
+boolean -> "true" {% () => true %}
+    | "false" {% () => false %}
+
+_ -> [ \t\n]:*
+
+additive -> multiplicative _ [+-] _ additive
+                {%
+                    (data) => {
+                        return {
+                            tag: "binop",
+                            sym: data[2],
+                            frst: data[0],
+                            scnd: data[4]
+                        };
+                    }
+                %}
+    | multiplicative {% id %}
+
+binop -> additive _ [+-<>=] _ binop
+            {%
+                (data) => {
+                    return {
+                        tag: "binop",
+                        sym: data[2],
+                        frst: data[0],
+                        scnd: data[4]
+                    };
+                }
+            %}
+        | multiplicative {% id %}
+
+binlog -> expr _ "&&" _ expr
+            {%
+                (data) => {
+                    return {
+                        tag: "binlog",
+                        sym: "&&",
+                        frst: data[0],
+                        scnd: data[4]
+                    };
+                }
+            %}
+         | expr _ "||" _ expr
+            {%
+                (data) => {
+                    return {
+                        tag: "binlog",
+                        sym: "||",
+                        frst: data[0],
+                        scnd: data[4]
+                    };
+                }
+            %}
+
+
+multiplicative -> unary_expr _ [*/] _ multiplicative
+                {%
+                    (data) => {
+                        return {
+                            tag: "binop",
+                            sym: data[2],
+                            frst: data[0],
+                            scnd: data[4]
+                        };
+                    }
+                %}
+    | unary_expr {% id %}
+
+unary_expr -> number {% id %}
+            | "(" _ additive _ ")"
+                {%
+                    (data) => {
+                        return {
+                            tag: "lit",
+                            val: data[2]
+                        }
+                    }
+                %}
+            | function {% id %}
+
+unop_expr -> "!" boolean
+                {%
+                    (data) => {
+                        return {
+                            tag: "unop",
+                            sym: "!",
+                            expr: data[1]
+                        };
+                    }
+                %}
+        | unary_expr {% id %}
+
+pgrm -> expr {% id %}
+
+expr -> value {% (data) => data[0] %}
+      | binop {% (data) => data[0] %}
+      | binlog {% (data) => data[0] %}
+      | unop_expr {% (data) => data[0] %}
+      | "(" expr ")" {% (data) => data[1] %}
+
+function -> builtin_fnct "(" _ args _ ")"
+                {%
+                    (data) => {
+                        const fn = data[0];
+                        const args = data[3];
+                        const fs = args[0];
+                        const sc = args[1];
+                        switch(fn) {
+                            case "sqrt":
+                                return fs * fs
+                        }
+                    }
+                %}
+
+args -> additive _ "," _ args {% data => [data[0], ...data[4]] %}
+    | additive {% data => [data[0]] %}
+
+builtin_fnct -> "sqrt" {% id %}
+
+operator -> [+\-*/] {% id %}
diff --git a/node_modules/js-slang/dist/parser/go-slang/go.peggy b/node_modules/js-slang/dist/parser/go-slang/go.peggy
new file mode 100644
index 0000000..fc06060
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/go.peggy
@@ -0,0 +1,26 @@
+{
+    package main
+    import "fmt"
+}
+
+GoFile = 'package' ws PackageName ws Imports ws Functions EOF
+
+PackageName = [a-zA-Z_][a-zA-Z_0-9]*
+
+Imports = ('import' ws '(' ImportList ')' / 'import' ws Import) ws
+
+Import = '"' [a-zA-Z0-9_/]+ '"'
+ImportList = Import (ws Import)*
+
+Functions = (Function ws)*
+
+Function = 'func' ws FunctionName ws '(' ')' ws '{' Statements '}'
+FunctionName = [a-zA-Z_][a-zA-Z_0-9]*
+
+Statements = (Statement ws)*
+Statement = [a-zA-Z_][a-zA-Z_0-9]* ws '=' ws Expression ';'
+Expression = [a-zA-Z_][a-zA-Z_0-9]* / '"' [^"]* '"' / [0-9]+
+
+ws = [ \t\n\r]*
+
+EOF = !.
diff --git a/node_modules/js-slang/dist/parser/go-slang/lexer.js b/node_modules/js-slang/dist/parser/go-slang/lexer.js
new file mode 100644
index 0000000..d164546
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/lexer.js
@@ -0,0 +1,292 @@
+const moo = require('moo');
+
+let lexer = moo.compile({
+    NL:        { match: /\n/, lineBreaks: true },
+    WS:        /[ \t]+/,
+    comment:   /\/\/.*?$/,
+    func_dec:   "func",
+    ret:       "return",
+    for:        "for",
+    if:         "if",
+    go:         "go",
+    else:       "else",
+    type:      ['int', 'float', 'string', 'bool'],
+    number:    /0|[1-9][0-9]*/,
+    string:    /"(?:\\["\\]|[^\n"\\])*"/,
+    boolean:   ['true', 'false'],
+    identifier: /[a-zA-Z_][a-zA-Z0-9_]*/,
+    not:       '!',
+    and:       '&&',
+    or:        '||',
+    plus:      '+',
+    minus:     '-',
+    mult:      '*',
+    div:       '/',
+    mod:        '%',
+    assign:    ':=',
+    lt:        '<',
+    gt:        '>',
+    equals:    '===',
+    lparen:    '(',
+    rparen:    ')',
+    lbrace:    '{',
+    rbrace:    '}',
+    keyword:   ['while', 'if', 'else', 'return'],
+    comma:     ',',
+    colon:     ':',
+});
+
+function tokenize(input) {
+    lexer.reset(input);
+    let tokens = [], currentToken;
+    while (currentToken = lexer.next()) {
+        if (currentToken.type !== 'WS' && currentToken.type !== 'comment') {
+            tokens.push(currentToken);
+        }
+    }
+
+    return {
+        tag: "blk",
+        body: parseTokens(tokens, 0).output[0]
+    }
+}
+
+function parseTokens(tokens, startIndex) {
+    let output = [];
+    let i = startIndex;
+    let stmts = [];
+
+    while (i < tokens.length) {
+        let token = tokens[i];
+        switch (token.type) {
+            case 'NL':
+                // New line might indicate the end of a statement
+                // if (stmts.length > 0) {
+                //     // If there are collected statements, push them as a sequence
+                //     output.push({tag: "seq", stmts: stmts});
+                //     stmts = []; // Reset for the next possible sequence
+                // }
+                i++;
+                break;
+            case "go":
+                // Expect the next tokens to form a function call
+                i++; // Move past 'go'
+                const goroutineResult = parseFunctionCall(tokens, i);
+                stmts.push({
+                    tag: 'goroutine',
+                    call: goroutineResult.result
+                });
+                i = goroutineResult.nextIndex; // Adjust index after processing the goroutine call
+                break;
+            case "for":
+                const forResult = parseFor(tokens, i);
+                stmts.push(forResult.result);
+                i = forResult.nextIndex - 1; // Adjust index after processing the loop
+                break;
+            case "if":
+                const ifResult = parseConditional(tokens, i);
+                stmts.push(ifResult.result);
+                i = ifResult.nextIndex; // should be correctly set by parseConditional
+                break;
+            case "ret":
+                const exprResult = parseExpression(tokens, i + 1);
+                stmts.push({
+                    tag: "ret",
+                    expr: exprResult.result
+                });
+                i = exprResult.nextIndex; // move beyond the parsed expression
+                break;
+            case "func_dec":
+                // Similar to above cases
+                break;
+            case 'identifier':
+                if (tokens[i + 1] && tokens[i + 1].type === 'assign') {
+                    i += 2; // Skip 'assign' and to the expression
+                    const expressionResult = parseExpression(tokens, i);
+                    stmts.push({
+                        tag: 'let',
+                        sym: token.value,
+                        expr: expressionResult.result
+                    });
+                    i = expressionResult.nextIndex; // move beyond the parsed expression
+                } else {
+                    stmts.push({ tag: 'nam', val: token.value });
+                    i++;
+                }
+                break;
+            case 'not':
+                // Ensure unary operation parsing also correctly updates `i`
+                let operand = tokens[++i];
+                    stmts.push({
+                        tag: 'unop',
+                        sym: '!',
+                        frst: { tag: 'lit', val: operand.value }
+                    });
+                i++;
+                break;
+            default:
+                if (['plus', 'minus', 'mult', 'div', 'lt', 'gt', 'equals', 'and', 'or', 'mod'].includes(token.type)) {
+                    let left = output.pop();
+                    i++; // Move to right operand
+                    const rightResult = parseExpression(tokens, i);
+                    stmts.push({
+                        tag: 'binop',
+                        sym: token.value,
+                        frst: left,
+                        scnd: rightResult.result
+                    });
+                    i = rightResult.nextIndex; // move beyond the parsed right expression
+                } else {
+                    stmts.push({ tag: 'lit', val: token.value });
+                    i++;
+                }
+                break;
+        }
+    }
+
+    // If there are remaining statements after the last newline, wrap them in a sequence
+    if (stmts.length > 1) {
+        output.push({tag: "seq", stmts: stmts});
+    } else {
+        output.push(stmts[0])
+    }
+
+    return {output: output, nextIndex: i};
+}
+
+function parseComplexStructure(tokens, startIndex, type) {
+    // Parsing complex structures like functions, loops, conditions
+    // This function needs to be implemented based on your specific language constructs
+    // Placeholder function below
+    return {
+        result: {tag: type, content: "Parsed content of " + type},
+        nextIndex: startIndex + 1 // Just a placeholder increment
+    };
+}
+
+function parseConditional(tokens, startIndex) {
+    let i = startIndex + 1; // Move past 'if'
+    let condition = [];
+    while (i < tokens.length && tokens[i].type !== 'lbrace') {
+        condition.push(tokens[i]);
+        i++;
+    }
+    if (i < tokens.length) i++; // Safely move past '{'
+    const conditionExpr = parseTokens(condition, 0).output;
+
+    let cons = [];
+    let isLbrace = 0;
+    while (i < tokens.length && (tokens[i].type !== 'rbrace' || isLbrace > 0)) {
+        if (tokens[i].type === 'lbrace') isLbrace++;
+        if (tokens[i].type === 'rbrace') isLbrace--;
+        cons.push(tokens[i]);
+        i++;
+    }
+    if (i < tokens.length) i++; // Safely move past '}'
+    const consExpr = parseTokens(cons, 0).output;
+
+    let alt = { "tag": "seq", "stmts": [] };
+    if (i < tokens.length && tokens[i].type === "else") {
+        i++;
+        if (i < tokens.length && tokens[i].type === 'if') {
+            const altResult = parseConditional(tokens, i);
+            alt = altResult.result;
+            i = altResult.nextIndex;
+        } else if (i < tokens.length && tokens[i].type === 'lbrace') {
+            let elseCons = [];
+            i++; // Move past '{'
+            while (i < tokens.length && tokens[i].type !== 'rbrace') {
+                elseCons.push(tokens[i]);
+                i++;
+            }
+            if (i < tokens.length) i++; // Safely move past '}'
+            const elseExpr = parseTokens(elseCons, 0).output;
+            alt = elseExpr;
+        }
+    }
+
+    return {
+        result: {
+            tag: "cond_stmt",
+            pred: conditionExpr,
+            cons: consExpr,
+            alt: alt
+        },
+        nextIndex: i
+    };
+}
+
+// This is a placeholder, you should implement parsing based on actual expected structures
+function parseExpression(tokens, startIndex) {
+    let expr = [];
+    let i = startIndex;
+    while (i < tokens.length && tokens[i].type !== 'rbrace' && tokens[i].type !== 'NL') {
+        expr.push(tokens[i]);
+        i++;
+    }
+    return {
+        result: tokenize(expr.map(t => t.value).join(" "))[0], // Concatenating expressions for simplicity
+        nextIndex: i
+    };
+}
+
+function parseFor(tokens, startIndex) {
+    let i = startIndex + 1; // Move past 'for'
+    let condition = [];
+    // Ensure i is within bounds and check for the start of the body
+    while (i < tokens.length && tokens[i].type !== 'lbrace') {
+        condition.push(tokens[i]);
+        i++;
+    }
+    const conditionExpr = parseTokens(condition, 0).output;
+
+    let body = [];
+    if (i < tokens.length) i++; // Safely move past '{'
+    // Ensure i is within bounds and parse until the matching '}'
+    let isLbrace = 0;
+    while (i < tokens.length && (tokens[i].type !== 'rbrace' || isLbrace > 0)) {
+        if (tokens[i].type === 'lbrace') isLbrace++;
+        if (tokens[i].type === 'rbrace') isLbrace--;
+        body.push(tokens[i]);
+        i++;
+    }
+    const bodyExpr = parseTokens(body, 0).output;
+    if (i < tokens.length) i++; // Safely move past '}'
+
+    return {
+        result: {
+            tag: "for",
+            pred: conditionExpr,
+            body: bodyExpr
+        },
+        nextIndex: i+1
+    };
+}
+
+function parseFunctionCall(tokens, startIndex) {
+    let i = startIndex;
+    let functionName = tokens[i].value; // Assuming the function name immediately follows 'go'
+    i++; // Move past function name
+    let args = [];
+    if (tokens[i].type === 'lparen') {
+        i++; // Move past '('
+        while (i < tokens.length && tokens[i].type !== 'rparen') {
+            args.push(tokens[i].value); // Simplify: assume args are literals or identifiers
+            i++;
+            if (tokens[i].type === 'comma') i++; // Skip commas
+        }
+        i++; // Move past ')'
+    }
+    return {
+        result: {
+            func: functionName,
+            args: args
+        },
+        nextIndex: i
+    };
+}
+
+// Test with a sample input
+console.log(tokenize('5 \n 2'));
+
+
diff --git a/node_modules/js-slang/dist/parser/go-slang/testParser.js b/node_modules/js-slang/dist/parser/go-slang/testParser.js
new file mode 100644
index 0000000..2e5b5f2
--- /dev/null
+++ b/node_modules/js-slang/dist/parser/go-slang/testParser.js
@@ -0,0 +1,11 @@
+const nearley = require("nearley");
+const grammar = require("./go.js");
+
+const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
+
+try {
+    parser.feed(`test := 5`);
+    console.log(parser.results); // Use JSON.stringify for better visibility of the object structure
+} catch (error) {
+    console.error("Parsing error:", error.message);
+}
